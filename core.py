from __future__ import annotations

import math
import os
import random
import tempfile
import pygame

#values generated by ai
# ── Window ─────────────────────────────────────────────────────
W, H = 1440, 860
PANEL_W = 350
TRACK_W = W - PANEL_W
FPS_NORMAL = 60
FPS_FAST = 0
MAX_TICKS = 1500
STALL_TICKS = 350

# ── Car tuning ─────────────────────────────────────────────────
CAR_WIDTH, CAR_HEIGHT = 18, 36
MAX_SPEED = 8.5
MIN_SPEED = -2.0
ACCELERATION = 0.32
BRAKE_FORCE = 0.55
FRICTION = 0.05
TURN_SPEED = 4.2
NUM_RAYS = 10
RAY_LENGTH = 220
RAY_SPREAD = math.pi * 1.1  # ~200 degrees

# ── Colours ────────────────────────────────────────────────────
C_ROAD = (90, 150, 90)
C_GRASS = (34, 52, 28)
C_PANEL_BG = (18, 18, 26)
C_ACCENT = (0, 220, 160)
C_ACCENT2 = (90, 140, 255)
C_ACCENT3 = (255, 180, 50)
C_RED = (255, 70, 70)
C_WHITE = (235, 235, 240)
C_DIM = (140, 140, 155)
C_GRAPH_BG = (28, 28, 42)
C_GRID = (44, 44, 60)

NEAT_CONFIG_STR =  """
[NEAT]
fitness_criterion     = max
fitness_threshold     = 999999999
pop_size              = {pop_size}
reset_on_extinction   = True

[DefaultGenome]
activation_default      = tanh
activation_mutate_rate  = 0.08
activation_options      = tanh sigmoid relu

aggregation_default     = sum
aggregation_mutate_rate = 0.05
aggregation_options     = sum

bias_init_mean          = 0.0
bias_init_stdev         = 1.0
bias_max_value          = 30.0
bias_min_value          = -30.0
bias_mutate_power       = 0.5
bias_mutate_rate        = 0.7
bias_replace_rate       = 0.1

compatibility_disjoint_coefficient = 1.0
compatibility_weight_coefficient   = 0.5

conn_add_prob           = 0.5
conn_delete_prob        = 0.5

enabled_default         = True
enabled_mutate_rate     = 0.01

feed_forward            = True
initial_connection      = full_direct

node_add_prob           = 0.3
node_delete_prob        = 0.3

num_hidden              = 0
num_inputs              = {num_inputs}
num_outputs             = 3

response_init_mean      = 1.0
response_init_stdev     = 0.0
response_max_value      = 30.0
response_min_value      = -30.0
response_mutate_power   = 0.0
response_mutate_rate    = 0.0
response_replace_rate   = 0.0

weight_init_mean        = 0.0
weight_init_stdev       = 1.0
weight_max_value        = 30
weight_min_value        = -30
weight_mutate_power     = 0.5
weight_mutate_rate      = 0.8
weight_replace_rate     = 0.1

[DefaultSpeciesSet]
compatibility_threshold = 3.0

[DefaultStagnation]
species_fitness_func = max
max_stagnation       = 20
species_elitism      = 2

[DefaultReproduction]
elitism            = 3
survival_threshold = 0.2
"""

def write_neat_config(pop_size= 35):
    txt = NEAT_CONFIG_STR.format(pop_size = pop_size , num_inputs = NUM_RAYS)
    path = os.path.join(tempfile.gettempdir(), "neat_cars_cfg.txt")
    with open(path, "w") as f:
        f.write(txt)
    return path

class Car:
    #car with physics, rays, and checkpoints
    def __init__(self, x, y, angle = -90):
        self._spawn = (x, y, angle)
        self.x = x
        self.y = y
        self.angle = angle
        self.speed = 0.0
        self.alive = True

        self.dist=0.0
        self.ticks=0
        self.checkpoint_hit = 0
        self.next_cp = 0


        self.ray_d = [1.0]*NUM_RAYS
        self.ray_end = [(0.0, 0.0)]*NUM_RAYS
        Car._car_count += 1
        self.surf = self._build_sprite()

    def _build_sprite(self):
        s = pygame.Surface((CAR_WIDTH, CAR_HEIGHT), pygame.SRCALPHA)
        pygame.draw.rect(s, self.color, (0, 0, CAR_WIDTH, CAR_HEIGHT), border_radius=5)
        pygame.draw.rect(s, (30, 30, 30), (2, 2, CAR_WIDTH-4, 9), border_radius=3)
        return s
    
    def reset(self):
        self.x, self.y, self.angle = self._spawn
        self.speed = 0.0
        self.dist = 0.0
        self.ticks = 0
        self.checkpoint_hit = 0
        self.next_cp = 0
        self.alive = True
        self.ray_d = [1.0]*NUM_RAYS

    def update(self, steer, accel, brake):
        if self.alive == False:
            return
        
        #only let car steer when it is moving
        if abs(self.speed)>0.15:
            angle = steer*TURN_SPEED*min(1, abs(self.speed)/MAX_SPEED)
            self.angle += angle

        #friction, brake, accelearte
        self,speed += accel*ACCELERATION-brake*BRAKE_FORCE
        if abs(self.speed) > FRICTION:
            if self.speed > 0:
                self.speed -= FRICTION
            elif self.speed < 0:
                self.speed += FRICTION
        
        else:
            self.speed = 0
        self.speed = max(MIN_SPEED, min(MAX_SPEED, self.speed))

        #how much to move
        heading = math.radians(self.angle)
        self.x += math.sin(heading)*self.speed
        self.y -= math.cos(heading)*self.speed
        self.dist += abs(self.speed)
        self.ticks += 1

    def cast_rays(self, mask):
        #casts rays and records distance
        base = math.radians(self.angle)
        start = base - RAY_SPREAD/2
        step = RAY_SPREAD/max(NUM_RAYS-1, 1)
        mw, mh = mask.get_size()
        
        for i in range(NUM_RAYS):
            a = start + step * i
            #used ai for the math to measure distance 
            sin_a, cos_a = math.sin(a), -math.cos(a)
            dist = RAY_LENGTH

            for r in range(4, RAY_LENGTH+1, 4):
                px = int(self.x + sin_a *r)
                py = int(self.y + cos_a * r)
                if px < 0 or py < 0 or px >= mw or py >= mh or mask.get_at((px, py))[1] < 100:
                    dist = r
                    break
            self.ray_d[i] = dist / RAY_LENGTH
            self.ray_end[i] = (self.x + sin_a * dist, self.y+cos_a*dist)

    def check_collision(self, mask):
        if self.alive == False:
            return False
        
        #ai for this method as well (math)
        rad = math.radians(self.angle)
        cos_a, sin_a = math.cos(rad), math.sin(rad)
        hw, hh = CAR_WIDTH / 2, CAR_HEIGHT / 2
        mw, mh = mask.get_size()

        for dx, dy in [(-hw, -hh), (hw, -hh), (hw, hh), (-hw, hh)]:
            px = int(dx * cos_a - dy * sin_a + self.x)
            py = int(dx * sin_a + dy * cos_a + self.y)
            if px < 0 or py < 0 or px >= mw or py >= mh or mask.get_at((px, py))[1] < 100:
                self.alive = False
                return True
        return False
    
    def check_checkpoints(self, checkpoints, tick):
        if self.alive == False or checkpoints == False:
            return
        if self.next_cp < len(checkpoints) and checkpoints[self.next_cp].collidepoint(self.x, self.y):
            self.cp_hit += 1
            self.next_cp = (self.next_cp + 1) % len(checkpoints)
        

    def nn_inputs(self):
        return list(self.ray_d)
    
    def fitness(self):
        #math done with ai
        return self.dist * 1.2 + self.cp_hit * 800 + self.ticks * 0.01
    
    def draw(self, surf, cam_x, cam_y, rays = False):
        if self.alive == False:
            return
        sx, sy = self.x - cam_x, self.y - cam_y
        #partially ai
        if rays:
            for i in range(NUM_RAYS):
                ex, ey = self.ray_end[i]
                d = self.ray_d[i]
                color = (int(255 * (1 - d)), int(255 * d), 50)
                pygame.draw.line(surf, color,
                                 (int(sx), int(sy)),
                                 (int(ex - cam_x), int(ey - cam_y)), 1)

        rotated = pygame.transform.rotate(self.surf, -self.angle)
        rect = rotated.get_rect(center=(int(sx), int(sy)))
        surf.blit(rotated, rect.topleft)



